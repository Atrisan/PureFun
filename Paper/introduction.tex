\section{Introduction}

% TODO: Cite MontiCore book!

Today's software and the software development process itself have grown larger and became more complex. But to develop these complex software in a way that functional and non-functional requirements such as scalability, performance, security and maintainability are preserved, we need tools and languages that support us in the software development process.  Especially the non-functional requirements are becoming more important in different domains like automotive, traffic or aerospace. Because of the complexity, the size of software and getting more people involved, code may become very error prone and developer need more time to fix bugs. To tackle these problems, the discipline of software engineering has developed many ways and tools over the years.\\
In most software projects popular imperative languages like Java, C++, C etc. are used. However, in large projects with lots of lines of code, errors may sneak in and can lead to undesired side effects. Debugging and detection of these side effects cost a lot of time with testing.\\
In Addition to imperative languages, there are functional programming languages like Haskell or Scala, which don't have side effects in their functions. Every input of a function produces the same output, regardless how often the function was called. The problem with functional languages is that they're not fast compared to for example C++, programs are not scalable and code may be is not maintainable.\\
In this paper, we introduce PureFun, a language which tries to combine the advantages of imperative and functional programming languages. Functions written in PureFun have no side effects, but still use imperative programming instructions like loops or if-statements. Beyond that, PureFun has more convenient features like short and readable notations for lists and other built-in container types. Furthermore to take advantage of no side effects, PureFun has a built-in \lstinline{async}{} keyword, which can execute instructions without side effects parallel in a new thread. We developed PureFun with MontiCore, a language workbench developed by the Chair for Software Engineering of the RWTH Aachen University. MontiCore generates the parser and other useful infrastructure using the grammar for our language such that we can extend PureFun very easily. To provide performance and less type checking in our tool, we decided to generate C++ code from PureFun code instead of interpret code directly.\\
In chapter 2 of this paper, we introduce parts of the MontiCore grammar of PureFun and further discuss why we used C++ in our generator. The pureness and how it is realized in PureFun is presented in chapter 3. After that we introduce the core features of PureFun such as the built in container types, the \lstinline{async}{} keyword and how we perform type checking for PureFun in our tool. Chapter 5 concludes this paper and gives an outlook into future plans and improvements of the PureFun language.