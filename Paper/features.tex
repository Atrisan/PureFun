\section{Features}
In this section we introduce the major features of PureFun. These features include the container types, the type checking and the async feature.
\subsection{Container Types}
The support for the container types list, tuple and map are natively embedded in PureFun. Other than data structures container are mutable.
\subsubsection{List}
Lists are similar to arrays. They contain an arbitrary number of elements sharing the same type.

\begin{figure}
\begin{lstlisting}[caption={PureFun code with a list and its predefined functions.},label={ListEx}]
module List {
  list : [Int] = [42,31,69,420]
  fun f () : Void {
    length : Int = #list
    first : Int = list[0]
    newList : [Int] = list ++ [666]
  }
}
\end{lstlisting}
\end{figure}
In listing \ref{ListEx} an example of a list and its predefined functions can be observed. The second line of the listing declares a new global variable named \texttt{list} as a list of \texttt{Int}, which is a 32 bit integer. The variable is instantiated by the list containing the numbers: 42, 31, 69, 420. A list can be instantiated by listing the elements separated by a comma and enclosed by brackets.\\
In line 4-6 the predefined functions are used. The first function using the \texttt{\#} symbol is a short hand notation for the length of a list. The access to individual elements of the list is the same as for the access of array elements in C, using the name of the variable followed by the index in brackets. The last function in line 6 is a short hand notation for the concatenation of two list. In this example the list \texttt{newList} becomes [42,31,69,420,666].\\
PureFun lists are mapped to C++ vectors during the code generation to avoid out of bounds access. Since the size of a list can change, out of bounds access can only be checked during runtime, to avoid large overheads during code generation.
\subsubsection{Tuple}
Tuples are container types, which contain a fixed number of elements. The elements of a tuple do not need to have the same type.

Listing \ref{TupleEx} depicts a tuple declaration and its predefined functions. Line 2 declares a tuple with two elements named \texttt{student}, the first element is of type integer and the second one of type string. It is instantiated by the tuple (235212, "Mustermann"). In general a tuple is instantiated by listing the elements enclosed in round brackets.\\
The predefined functions in line 4 and 5 are the same as for the list type. Where the first is a shorthand for the number of elements and the second one is the notation to access a specific element in the tuple.\\
PureFun tuples are mapped to C++ tuples during code generation, for performance reasons and simplicity.
\begin{figure}
\begin{lstlisting}[caption={PureFun code with a tuple and its predefined functions.},label={TupleEx}]
module Tuple {
  student : (Int,String) = (235212, "Mustermann")
  fun f () : Void {
    length : Int = #student
    name : String = student[1]
  }
}
\end{lstlisting}
\end{figure}
\subsubsection{Map}
Maps are a list of key value pairs, where all keys and all values share the same type respectively.

Listing \ref{MapEx} shows the declaration and instantiation of a map in PureFun. Similar to the other container types the map \texttt{students} is declared in line 2. The map has keys of type integer and values of type string, which is denoted as [\textit{key}:\textit{value}]. The instantiation is done by listing the key value pairs (\textit{key}:\textit{value}) in curly brackets.\\
The predefined functions in lines 4-7 are defined as follows:
\begin{itemize}
\item \texttt{\#students}: the number of key value pairs.
\item \texttt{students[235212]}: the value corresponding to the key \texttt{235212}
\item \texttt{@students}: the list of all keys
\item \texttt{\$students}: the list of all values
\end{itemize}
PureFun maps are mapped to C++ unordered maps for performance reasons and simplicity.
\begin{figure}
\begin{lstlisting}[caption={PureFun code with a map and its predefined functions.},label={MapEx}]
module Map {
  students : [Int:String] = {235212: "Mustermann", 123456:"Test"}
  fun f () : Void {
    length : Int = #students
    name : String = students[235212]
    keys : [Int] = @students
    values: [String] = $students
  }
}
\end{lstlisting}
\end{figure}
\subsection{Type Checking}

Since we have different types in the PureFun language, it's obligatory to think about implementing type checking in our generator tool. Due to time limitations, we decided to implement type checking partially. We only check primitive types like Int, Strings etc. and our built in container types lists, maps and tuple as well. The only types we don't check yet are user-defined data structures defined with the \texttt{data} keyword. We leave the rest of type checking to the C++ compiler.\\
At the time we developed this version of the PureFun language, MontiCore was not capable to generate a rough infrastructure for type resolving. Hence we had to implement the whole type system infrastructure in Java ourselves. Fig. \ref{typeinfrfig1} shows the type infrastructure we implemented in an UML diagram with the most important methods.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{img/PureFunType.png}
	\caption{PureFun type infrastructure UML diagram}
	\label{typeinfrfig1}
\end{figure}

All types are implementing the PureFunType interface, which provides the methods \texttt{getTypeString()} and \texttt{equals(PureFunType)}. \texttt{getTypeString()} returns the corresponding PureFun type as a \texttt{String}. The PureFunType interface has a default implementation of \texttt{equals} which compares the two type strings with the \texttt{getTypeString} method. This suffices in most cases, but if you think about something like \texttt{var Double = 1}, this \texttt{equals} method would return \texttt{false} for the types of \texttt{var} which is \texttt{"Double"} and \texttt{1} which is an \texttt{Int}. To make this work, we first created the enum \texttt{PureFunPrimitiveType} which contains all primitive types we have in our language. So if we want to extend the primitive datatypes in PureFun with another one, we just have to add it in the \texttt{PureFunPrimitiveType} enum. In addition to the \texttt{PureFunPrimitiveType} enum, we created the class \texttt{PureFunCommonType} which essentially extends the primitive types with the types \texttt{Void} for return values of functions and the type \texttt{Arbitrary} which is mapped to all user-defined types and also the empty list \texttt{[]} for example. The class \texttt{PureFunCommonType} also provides further methods which i.e. can check whether a type is a number type (like \texttt{Int}, \texttt{Float}, \texttt{Double} etc.). With that method we can check whether something like \texttt{var Double = 1} is well typed or not.\\
For lists, we provide the class \texttt{PureFunListType}. Each list has a sub type. The empty list, has the sub type arbitrary, because every list can be instantiated with the empty list. The \texttt{equals} method of \texttt{PureFunType} is overridden here and checks whether sub types of lists are equal or one of them has the arbitrary type.\\
Maps have the \texttt{PureFunMapType} which obviously has a key and a value type. The \texttt{equals} method is overridden here as well like in the \texttt{PureFunListType} class. Here it checks whether key and value type are equal or arbitrary for the empty map.\\
Lastly there is the \texttt{PureFunTupleType} which is similar to \texttt{PureFunListType} but it has multiple sub types. The \texttt{equals} method checks here whether all sub types are equal or if the given tuple type has no subtypes. If the latter is the case, it's the empty tuple.\\
Now that we have our type system infrastructure, we can compare our types. Before we can implement our type checking context conditions, we have to resolve the types. What we get from the AST are only the \texttt{ASTType}s for definitions of variables and functions, \texttt{ASTExpression}s from all the expressions in our language like for example our built in functions for lists and last but not least \texttt{ASTLiteral}s like \texttt{5}, \texttt{31.0}, \texttt{"Hello"} and so on. We have to resolve all the AST classes and map our \texttt{PureFunType}s to them. For that, we created the classes \texttt{PureFunTypeConverter}, \texttt{ExpressionTypesResolver} and \texttt{LiteralTypesResolver}.\\
\texttt{PureFunTypeConverter} has a method \texttt{convertFromAST} which takes an \texttt{ASTType} and returns the corresponding \texttt{PureFunType} object. If the method gets an \texttt{ASTListType} for example, it returns a new \texttt{PureFunListType} object and calls \texttt{convertFromAST} recursively for the sub type. Map and tuple types work analogous. For all other type names, it returns a \texttt{PureFunCommonType} object which has the type name as the type string.\\
\texttt{LiteralTypesResolver} works similar as \texttt{PureFunTypeConverter} but with \texttt{ASTLiteral}. The class provides a method \texttt{resolveType} which takes an \texttt{ASTLiteral} and resolves the type for it corresponding to its subclass. For example if \texttt{resolveType} gets an \texttt{ASTIntLiteral}, then \texttt{resolveType} returns the \texttt{INT} constant from the \texttt{PureFunPrimitiveType} enum. The method works analogous for all other \texttt{ASTLiteral} subclasses.\\

\subsection{Async}
